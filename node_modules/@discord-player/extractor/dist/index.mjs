var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/extractors/SoundCloudExtractor.ts
import {
  BaseExtractor,
  Playlist,
  QueryType,
  Track,
  Util
} from "discord-player";
import { Client } from "soundcloud-scraper";
var soundcloud = new Client(void 0, {
  fetchAPIKey: true
});
var SoundCloudExtractor = class extends BaseExtractor {
  async validate(query, type) {
    if (typeof query !== "string")
      return false;
    return [QueryType.SOUNDCLOUD, QueryType.SOUNDCLOUD_PLAYLIST, QueryType.SOUNDCLOUD_SEARCH, QueryType.SOUNDCLOUD_TRACK].some((r) => r === type);
  }
  async getRelatedTracks(track) {
    if (track.queryType === QueryType.SOUNDCLOUD_TRACK)
      return this.handle(track.author || track.title, {
        requestedBy: track.requestedBy,
        type: QueryType.SOUNDCLOUD_SEARCH
      });
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType.SOUNDCLOUD_TRACK: {
        const trackInfo = await soundcloud.getSongInfo(query, {
          fetchComments: false,
          fetchEmbed: false,
          fetchStreamURL: true
        }).catch(Util.noop);
        if (!trackInfo)
          return this.emptyResponse();
        const track = new Track(this.context.player, {
          title: trackInfo.title,
          url: trackInfo.url,
          duration: Util.buildTimeCode(Util.parseMS(trackInfo.duration)),
          description: trackInfo.description,
          thumbnail: trackInfo.thumbnail,
          views: trackInfo.playCount,
          author: trackInfo.author.name,
          requestedBy: context.requestedBy,
          source: "soundcloud",
          engine: trackInfo,
          queryType: context.type
        });
        return { playlist: null, tracks: [track] };
      }
      case QueryType.SOUNDCLOUD_PLAYLIST: {
        const data = await soundcloud.getPlaylist(query, {
          fetchEmbed: false
        }).catch(Util.noop);
        if (!data)
          return { playlist: null, tracks: [] };
        const res = new Playlist(this.context.player, {
          title: data.title,
          description: data.description ?? "",
          thumbnail: data.thumbnail ?? "https://soundcloud.com/pwa-icon-192.png",
          type: "playlist",
          source: "soundcloud",
          author: {
            name: data.author?.name ?? data.author?.username ?? "Unknown Artist",
            url: data.author?.profile
          },
          tracks: [],
          id: `${data.id}`,
          url: data.url,
          rawPlaylist: data
        });
        for (const song of data.tracks) {
          const track = new Track(this.context.player, {
            title: song.title,
            description: song.description ?? "",
            author: song.author?.username ?? song.author?.name ?? "Unknown Artist",
            url: song.url,
            thumbnail: song.thumbnail,
            duration: Util.buildTimeCode(Util.parseMS(song.duration)),
            views: song.playCount ?? 0,
            requestedBy: context.requestedBy,
            playlist: res,
            source: "soundcloud",
            engine: song,
            queryType: context.type
          });
          res.tracks.push(track);
        }
        return { playlist: res, tracks: res.tracks };
      }
      default: {
        const tracks = await soundcloud.search(query, "track").catch(Util.noop);
        if (!tracks || !tracks.length)
          return this.emptyResponse();
        const resolvedTracks = [];
        for (const searchedTrack of tracks) {
          const trackInfo = await soundcloud.getSongInfo(searchedTrack.url, {
            fetchStreamURL: true,
            fetchComments: false,
            fetchEmbed: false
          }).catch(Util.noop);
          if (!trackInfo)
            continue;
          const track = new Track(this.context.player, {
            title: trackInfo.title,
            url: trackInfo.url,
            duration: Util.buildTimeCode(Util.parseMS(trackInfo.duration)),
            description: trackInfo.description,
            thumbnail: trackInfo.thumbnail,
            views: trackInfo.playCount,
            author: trackInfo.author.name,
            requestedBy: context.requestedBy,
            source: "soundcloud",
            engine: trackInfo,
            queryType: "soundcloudTrack"
          });
          resolvedTracks.push(track);
        }
        return { playlist: null, tracks: resolvedTracks };
      }
    }
  }
  emptyResponse() {
    return { playlist: null, tracks: [] };
  }
  async stream(info) {
    const engine = info.raw.engine;
    if (engine && engine.streamURL) {
      return engine.streamURL;
    }
    const url = await soundcloud.fetchStreamURL(info.url).catch(Util.noop);
    if (!url)
      throw new Error("Could not extract stream from this source");
    if (engine) {
      engine.streamURL = url;
    } else {
      info.raw.engine = {
        streamURL: url
      };
    }
    return url;
  }
};
__name(SoundCloudExtractor, "SoundCloudExtractor");
SoundCloudExtractor.identifier = "com.discord-player.soundcloudextractor";

// src/extractors/YoutubeExtractor.ts
import { YouTube as YouTube2 } from "youtube-sr";
import {
  BaseExtractor as BaseExtractor2,
  Playlist as Playlist2,
  QueryType as QueryType2,
  Track as Track2,
  Util as Util2
} from "discord-player";

// src/extractors/common/helper.ts
import { YouTube } from "youtube-sr";
var factory;
var createImport = /* @__PURE__ */ __name((lib) => import(lib).catch(() => null), "createImport");
var YouTubeLibs = [
  "ytdl-core",
  "play-dl",
  "@distube/ytdl-core"
];
var forcedLib = process.env.DP_FORCE_YTDL_MOD;
if (forcedLib)
  YouTubeLibs.unshift(forcedLib);
var getFetch = typeof fetch !== "undefined" ? fetch : async (...params) => {
  let dy;
  if (dy = await createImport("undici")) {
    return (dy.fetch || dy.default.fetch)(...params);
  } else if (dy = await createImport("node-fetch")) {
    return (dy.fetch || dy.default)(...params);
  } else {
    throw new Error("No fetch lib found");
  }
};
async function loadYtdl(options, force = false) {
  if (factory && !force)
    return factory;
  let lib, _ytLibName, _stream;
  for (const ytlib of YouTubeLibs) {
    lib = await import(ytlib).then(
      (m) => m,
      () => null
    );
    if (!lib)
      continue;
    lib = lib.default || lib;
    _ytLibName = ytlib;
    break;
  }
  if (lib) {
    const isYtdl = ["ytdl-core", "@distube/ytdl-core"].some((lib2) => lib2 === _ytLibName);
    _stream = /* @__PURE__ */ __name(async (query) => {
      if (isYtdl) {
        const dl = lib;
        const info = await dl.getInfo(query, options);
        const formats = info.formats.filter((format) => {
          return info.videoDetails.isLiveContent ? format.isHLS && format.hasAudio : format.hasAudio;
        }).sort((a, b) => Number(b.audioBitrate) - Number(a.audioBitrate) || Number(a.bitrate) - Number(b.bitrate));
        const fmt = formats.find((format) => !format.hasVideo) || formats.sort((a, b) => Number(a.bitrate) - Number(b.bitrate))[0];
        return fmt.url;
      } else {
        const dl = lib;
        const info = await dl.video_info(query);
        const formats = info.format.filter((format) => {
          const re = /\/manifest\/hls_(variant|playlist)\//;
          if (!format.url)
            return false;
          if (info.video_details.live)
            return re.test(format.url) && typeof format.bitrate === "number";
          return typeof format.bitrate === "number";
        }).sort((a, b) => Number(b.bitrate) - Number(a.bitrate));
        const fmt = formats.find((format) => !format.qualityLabel) || formats.sort((a, b) => Number(a.bitrate) - Number(b.bitrate))[0];
        return fmt.url;
      }
    }, "_stream");
  } else {
    throw new Error(`Could not load youtube library. Install one of ${YouTubeLibs.map((lib2) => `"${lib2}"`).join(", ")}`);
  }
  factory = { name: _ytLibName, stream: _stream, lib };
  return factory;
}
__name(loadYtdl, "loadYtdl");
async function makeYTSearch(query, opt) {
  const res = await YouTube.search(query, {
    type: "video",
    requestOptions: opt
  }).catch(() => {
  });
  return res || [];
}
__name(makeYTSearch, "makeYTSearch");

// src/extractors/YoutubeExtractor.ts
var validQueryDomains = /* @__PURE__ */ new Set(["youtube.com", "www.youtube.com", "m.youtube.com", "music.youtube.com", "gaming.youtube.com"]);
var validPathDomains = /^https?:\/\/(youtu\.be\/|(www\.)?youtube\.com\/(embed|v|shorts)\/)/;
var idRegex = /^[a-zA-Z0-9-_]{11}$/;
var _YoutubeExtractor = class extends BaseExtractor2 {
  async activate() {
    const { stream, name } = await loadYtdl(this.context.player.options.ytdlOptions);
    this._stream = stream;
    this._ytLibName = name;
  }
  async validate(query, type) {
    if (typeof query !== "string")
      return false;
    return [QueryType2.YOUTUBE, QueryType2.YOUTUBE_PLAYLIST, QueryType2.YOUTUBE_SEARCH, QueryType2.YOUTUBE_VIDEO, QueryType2.AUTO].some((r) => r === type);
  }
  async handle(query, context) {
    query = query.includes("youtube.com") ? query.replace(/(m(usic)?|gaming)\./, "") : query;
    if (_YoutubeExtractor.validateURL(query))
      context.type = QueryType2.YOUTUBE_VIDEO;
    switch (context.type) {
      case QueryType2.YOUTUBE_PLAYLIST: {
        const ytpl = await YouTube2.getPlaylist(query, {
          fetchAll: true,
          requestOptions: context.requestOptions
        }).catch(Util2.noop);
        if (!ytpl)
          return this.emptyResponse();
        const playlist = new Playlist2(this.context.player, {
          title: ytpl.title,
          thumbnail: ytpl.thumbnail,
          description: ytpl.title || "",
          type: "playlist",
          source: "youtube",
          author: {
            name: ytpl.channel.name,
            url: ytpl.channel.url
          },
          tracks: [],
          id: ytpl.id,
          url: ytpl.url,
          rawPlaylist: ytpl
        });
        playlist.tracks = ytpl.videos.map(
          (video) => new Track2(this.context.player, {
            title: video.title,
            description: video.description,
            author: video.channel?.name,
            url: video.url,
            requestedBy: context.requestedBy,
            thumbnail: video.thumbnail.url,
            views: video.views,
            duration: video.durationFormatted,
            raw: video,
            playlist,
            source: "youtube",
            queryType: "youtubeVideo"
          })
        );
        return { playlist, tracks: playlist.tracks };
      }
      case QueryType2.YOUTUBE_VIDEO: {
        const id = /[a-zA-Z0-9-_]{11}/.exec(query);
        if (!id?.[0])
          return this.emptyResponse();
        const video = await YouTube2.getVideo(`https://www.youtube.com/watch?v=${id}`, context.requestOptions).catch(Util2.noop);
        if (!video)
          return this.emptyResponse();
        video.source = "youtube";
        return {
          playlist: null,
          tracks: [
            new Track2(this.context.player, {
              title: video.title,
              description: video.description,
              author: video.channel?.name,
              url: video.url,
              requestedBy: context.requestedBy,
              thumbnail: video.thumbnail?.displayThumbnailURL("maxresdefault"),
              views: video.views,
              duration: video.durationFormatted,
              source: "youtube",
              raw: video,
              queryType: context.type
            })
          ]
        };
      }
      default: {
        const tracks = await this._makeYTSearch(query, context);
        return { playlist: null, tracks };
      }
    }
  }
  async _makeYTSearch(query, context) {
    const res = await makeYTSearch(query, context.requestOptions).catch(Util2.noop);
    if (!res || !res.length)
      return [];
    return res.map((video) => {
      video.source = "youtube";
      return new Track2(this.context.player, {
        title: video.title,
        description: video.description,
        author: video.channel?.name,
        url: video.url,
        requestedBy: context.requestedBy,
        thumbnail: video.thumbnail?.displayThumbnailURL("maxresdefault"),
        views: video.views,
        duration: video.durationFormatted,
        source: "youtube",
        raw: video,
        queryType: context.type
      });
    });
  }
  async getRelatedTracks(track) {
    let info;
    if (_YoutubeExtractor.validateURL(track.url))
      info = await YouTube2.getVideo(track.url).then((x) => x.videos).catch(Util2.noop);
    if (!info)
      info = await YouTube2.search(track.author || track.title, { limit: 5, type: "video" }).then((x) => x).catch(Util2.noop);
    if (!info?.length) {
      return this.createResponse();
    }
    const similar = info.map(
      (video) => new Track2(this.context.player, {
        title: video.title,
        url: `https://www.youtube.com/watch?v=${video.id}`,
        duration: video.durationFormatted || Util2.buildTimeCode(Util2.parseMS(video.duration * 1e3)),
        description: video.title,
        thumbnail: typeof video.thumbnail === "string" ? video.thumbnail : video.thumbnail.url,
        views: video.views,
        author: video.channel.name,
        requestedBy: track.requestedBy,
        source: "youtube",
        queryType: "youtubeVideo"
      })
    );
    return this.createResponse(null, similar);
  }
  emptyResponse() {
    return { playlist: null, tracks: [] };
  }
  async stream(info) {
    if (!this._stream) {
      throw new Error(`Could not find youtube streaming library. Install one of ${YouTubeLibs.join(", ")}`);
    }
    let url = info.url;
    if (info.queryType === "spotifySong" || info.queryType === "appleMusicSong") {
      if (_YoutubeExtractor.validateURL(info.raw.url))
        url = info.raw.url;
      else {
        const _url = await YouTube2.searchOne(`${info.title} ${info.author}`, "video").then((r) => r.url).catch(Util2.noop);
        if (!_url)
          throw new Error(`Could not extract stream for this track`);
        info.raw.url = url = _url;
      }
    }
    if (url)
      url = url.includes("youtube.com") ? url.replace(/(m(usic)?|gaming)\./, "") : url;
    return this._stream(url);
  }
  static validateURL(link) {
    try {
      _YoutubeExtractor.parseURL(link);
      return true;
    } catch {
      return false;
    }
  }
  static validateId(id) {
    return idRegex.test(id.trim());
  }
  static parseURL(link) {
    const parsed = new URL(link.trim());
    let id = parsed.searchParams.get("v");
    if (validPathDomains.test(link.trim()) && !id) {
      const paths = parsed.pathname.split("/");
      id = parsed.host === "youtu.be" ? paths[1] : paths[2];
    } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {
      throw Error("Not a YouTube domain");
    }
    if (!id) {
      throw Error(`No video id found: "${link}"`);
    }
    id = id.substring(0, 11);
    if (!exports.validateID(id)) {
      throw TypeError(`Video id (${id}) does not match expected format (${idRegex.toString()})`);
    }
    return id;
  }
};
var YoutubeExtractor = _YoutubeExtractor;
__name(YoutubeExtractor, "YoutubeExtractor");
YoutubeExtractor.identifier = "com.discord-player.youtubeextractor";

// src/extractors/LyricsExtractor.ts
import { Client as GeniusClient } from "genius-lyrics";
var client;
function lyricsExtractor(apiKey, force) {
  if (!client && !force)
    client = new GeniusClient(apiKey);
  return { search, client };
}
__name(lyricsExtractor, "lyricsExtractor");
function search(query) {
  return new Promise((resolve, reject) => {
    if (typeof query !== "string")
      return reject(new TypeError(`Expected search query to be a string, received "${typeof query}"!`));
    client.songs.search(query).then(async (songs) => {
      const data = {
        title: songs[0].title,
        id: songs[0].id,
        thumbnail: songs[0].thumbnail,
        image: songs[0].image,
        url: songs[0].url,
        artist: {
          name: songs[0].artist.name,
          id: songs[0].artist.id,
          url: songs[0].artist.url,
          image: songs[0].artist.image
        },
        lyrics: await songs[0].lyrics(false)
      };
      resolve(data);
    }).catch(() => {
      reject(new Error("Could not parse lyrics"));
    });
  });
}
__name(search, "search");

// src/extractors/VimeoExtractor.ts
import {
  BaseExtractor as BaseExtractor3,
  QueryType as QueryType3,
  Track as Track3,
  Util as Util3
} from "discord-player";

// src/internal/Vimeo.ts
import http from "http";
import https from "https";
var Vimeo = class {
  constructor() {
    throw new Error(`The ${this.constructor.name} class may not be instantiated!`);
  }
  static download(id) {
    return new Promise(async (resolve) => {
      const info = await Vimeo.getInfo(id);
      if (!info)
        return null;
      const downloader = info.stream.startsWith("https://") ? https : http;
      downloader.get(info.stream, (res) => {
        resolve(res);
      });
    });
  }
  static async getInfo(id) {
    if (!id)
      throw new Error("Invalid id");
    const url = `https://player.vimeo.com/video/${id}`;
    try {
      const res = await getFetch(url);
      const data = await res.text();
      const json = JSON.parse(data.split("window.playerConfig =")[1].split(";")[0].trim());
      const obj = {
        id: json.video.id,
        duration: json.video.duration * 1e3,
        title: json.video.title,
        url: json.video.url,
        thumbnail: json.video.thumbs["1280"] || json.video.thumbs.base,
        stream: json.request.files.progressive[0].url,
        author: {
          id: json.video.owner.id,
          name: json.video.owner.name,
          url: json.video.owner.url,
          avatar: json.video.owner.img_2x || json.video.owner.img
        }
      };
      return obj;
    } catch {
      return null;
    }
  }
};
__name(Vimeo, "Vimeo");

// src/extractors/VimeoExtractor.ts
var VimeoExtractor = class extends BaseExtractor3 {
  async validate(query, type) {
    if (typeof query !== "string")
      return false;
    return [QueryType3.VIMEO].some((r) => r === type);
  }
  async getRelatedTracks(track) {
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType3.VIMEO: {
        const trackInfo = await Vimeo.getInfo(
          query.split("/").filter((x) => !!x).pop()
        ).catch(Util3.noop);
        if (!trackInfo)
          return this.emptyResponse();
        const track = new Track3(this.context.player, {
          title: trackInfo.title,
          url: trackInfo.url,
          duration: Util3.buildTimeCode(Util3.parseMS(trackInfo.duration || 0)),
          description: `${trackInfo.title} by ${trackInfo.author.name}`,
          thumbnail: trackInfo.thumbnail,
          views: 0,
          author: trackInfo.author.name,
          requestedBy: context.requestedBy,
          source: "arbitrary",
          engine: trackInfo.stream,
          queryType: context.type
        });
        return { playlist: null, tracks: [track] };
      }
      default:
        return this.emptyResponse();
    }
  }
  emptyResponse() {
    return { playlist: null, tracks: [] };
  }
  async stream(info) {
    const engine = info.raw.engine;
    if (engine) {
      return engine;
    }
    const track = await Vimeo.getInfo(info.url).catch(Util3.noop);
    if (!track || !track.stream)
      throw new Error("Could not extract stream from this source");
    info.raw.engine = {
      streamURL: track.stream
    };
    return track.stream;
  }
};
__name(VimeoExtractor, "VimeoExtractor");
VimeoExtractor.identifier = "com.discord-player.vimeoextractor";

// src/extractors/ReverbnationExtractor.ts
import {
  BaseExtractor as BaseExtractor4,
  QueryType as QueryType4,
  Track as Track4,
  Util as Util4
} from "discord-player";
import reverbnation from "reverbnation-scraper";
var ReverbnationExtractor = class extends BaseExtractor4 {
  async validate(query, type) {
    if (typeof query !== "string")
      return false;
    return [QueryType4.REVERBNATION].some((r) => r === type);
  }
  async getRelatedTracks(track) {
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType4.REVERBNATION: {
        const trackInfo = await reverbnation.getInfo(query).catch(Util4.noop);
        if (!trackInfo)
          return this.emptyResponse();
        const track = new Track4(this.context.player, {
          title: trackInfo.title,
          url: trackInfo.url,
          duration: Util4.buildTimeCode(Util4.parseMS(trackInfo.duration)),
          description: trackInfo.lyrics || `${trackInfo.title} by ${trackInfo.artist.name}`,
          thumbnail: trackInfo.thumbnail,
          views: 0,
          author: trackInfo.artist.name,
          requestedBy: context.requestedBy,
          source: "arbitrary",
          engine: trackInfo.streamURL,
          queryType: context.type
        });
        return { playlist: null, tracks: [track] };
      }
      default:
        return this.emptyResponse();
    }
  }
  emptyResponse() {
    return { playlist: null, tracks: [] };
  }
  async stream(info) {
    const engine = info.raw.engine;
    if (engine) {
      return engine;
    }
    const track = await reverbnation.getInfo(info.url).catch(Util4.noop);
    if (!track || !track.streamURL)
      throw new Error("Could not extract stream from this source");
    info.raw.engine = {
      streamURL: track.streamURL
    };
    return track.streamURL;
  }
};
__name(ReverbnationExtractor, "ReverbnationExtractor");
ReverbnationExtractor.identifier = "com.discord-player.reverbnationextractor";

// src/extractors/AttachmentExtractor.ts
import {
  BaseExtractor as BaseExtractor5,
  QueryType as QueryType5,
  Track as Track5,
  Util as Util5
} from "discord-player";
import { createReadStream, existsSync } from "fs";

// src/internal/downloader.ts
import http2 from "http";
import https2 from "https";
function downloadStream(url, opts = {}) {
  return new Promise((resolve, reject) => {
    const lib = url.startsWith("http://") ? http2 : https2;
    lib.get(url, opts, (res) => resolve(res)).once("error", reject);
  });
}
__name(downloadStream, "downloadStream");

// src/extractors/AttachmentExtractor.ts
import { fromFile } from "file-type";
import path from "path";
import { stat } from "fs/promises";
var AttachmentExtractor = class extends BaseExtractor5 {
  async validate(query, type) {
    if (typeof query !== "string")
      return false;
    return [QueryType5.ARBITRARY, QueryType5.FILE].some((r) => r === type);
  }
  async getRelatedTracks(track) {
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType5.ARBITRARY: {
        const data = await downloadStream(query, context.requestOptions);
        if (!["audio/", "video/"].some((r) => !!data.headers["content-type"]?.startsWith(r)))
          return this.emptyResponse();
        const trackInfo = {
          title: (query.split("/").filter((x) => x.length).pop() ?? "Attachment").split("?")[0].trim(),
          duration: 0,
          thumbnail: "https://upload.wikimedia.org/wikipedia/commons/2/2a/ITunes_12.2_logo.png",
          engine: query,
          author: data.client?.servername || "Attachment",
          description: data.client?.servername || "Attachment",
          url: data.url || query
        };
        const track = new Track5(this.context.player, {
          title: trackInfo.title,
          url: trackInfo.url,
          duration: Util5.buildTimeCode(Util5.parseMS(trackInfo.duration)),
          description: trackInfo.description,
          thumbnail: trackInfo.thumbnail,
          views: 0,
          author: trackInfo.author,
          requestedBy: context.requestedBy,
          source: "arbitrary",
          engine: trackInfo.url,
          queryType: context.type
        });
        track.raw.isFile = false;
        return { playlist: null, tracks: [track] };
      }
      case QueryType5.FILE: {
        if (!existsSync(query))
          return this.emptyResponse();
        const fstat = await stat(query);
        if (!fstat.isFile())
          return this.emptyResponse();
        const mime = await fromFile(query).catch(() => null);
        if (!mime || !["audio/", "video/"].some((r) => !!mime.mime.startsWith(r)))
          return this.emptyResponse();
        const trackInfo = {
          title: path.basename(query) || "Attachment",
          duration: 0,
          thumbnail: "https://upload.wikimedia.org/wikipedia/commons/2/2a/ITunes_12.2_logo.png",
          engine: query,
          author: "Attachment",
          description: "Attachment",
          url: query
        };
        const track = new Track5(this.context.player, {
          title: trackInfo.title,
          url: trackInfo.url,
          duration: Util5.buildTimeCode(Util5.parseMS(trackInfo.duration)),
          description: trackInfo.description,
          thumbnail: trackInfo.thumbnail,
          views: 0,
          author: trackInfo.author,
          requestedBy: context.requestedBy,
          source: "arbitrary",
          engine: trackInfo.url,
          queryType: context.type
        });
        track.raw.isFile = true;
        return { playlist: null, tracks: [track] };
      }
      default:
        return this.emptyResponse();
    }
  }
  emptyResponse() {
    return { playlist: null, tracks: [] };
  }
  async stream(info) {
    const engine = info.raw.engine;
    const isFile = info.raw.isFile;
    if (!engine)
      throw new Error("Could not find stream source");
    if (!isFile) {
      return engine;
    }
    return createReadStream(engine);
  }
};
__name(AttachmentExtractor, "AttachmentExtractor");
AttachmentExtractor.identifier = "com.discord-player.attachmentextractor";

// src/extractors/AppleMusicExtractor.ts
import { BaseExtractor as BaseExtractor6, Playlist as Playlist3, QueryType as QueryType6, Track as Track6, Util as Util6 } from "discord-player";

// src/internal/index.ts
var internal_exports = {};
__export(internal_exports, {
  AppleMusic: () => AppleMusic,
  Vimeo: () => Vimeo,
  downloadStream: () => downloadStream
});

// src/internal/AppleMusic.ts
import { QueryResolver } from "discord-player";
import { parse } from "node-html-parser";
function getHTML(link) {
  return getFetch(link, {
    headers: {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.49"
    }
  }).then((r) => r.text()).then(
    (txt) => parse(txt),
    () => null
  );
}
__name(getHTML, "getHTML");
function makeImage({ height, url, width, ext = "jpg" }) {
  return url.replace("{w}", `${width}`).replace("{h}", `${height}`).replace("{f}", ext);
}
__name(makeImage, "makeImage");
function parseDuration(d) {
  const r = /* @__PURE__ */ __name((name, unit) => `((?<${name}>-?\\d*[\\.,]?\\d+)${unit})?`, "r");
  const regex = new RegExp(
    [
      "(?<negative>-)?P",
      r("years", "Y"),
      r("months", "M"),
      r("weeks", "W"),
      r("days", "D"),
      "(T",
      r("hours", "H"),
      r("minutes", "M"),
      r("seconds", "S"),
      ")?"
    ].join("")
  );
  const test = regex.exec(d);
  if (!test || !test.groups)
    return "0:00";
  const dur = [test.groups.years, test.groups.months, test.groups.weeks, test.groups.days, test.groups.hours, test.groups.minutes, test.groups.seconds];
  return dur.filter((r2, i, a) => !!r2 || i > a.length - 2).map((m, i) => {
    if (!m)
      m = "0";
    return i < 1 ? m : m.padStart(2, "0");
  }).join(":") || "0:00";
}
__name(parseDuration, "parseDuration");
var AppleMusic = class {
  constructor() {
    return AppleMusic;
  }
  static async search(query) {
    try {
      const url = `https://music.apple.com/us/search?term=${encodeURIComponent(query)}`;
      const node = await getHTML(url);
      if (!node)
        return [];
      const rawData = node.getElementById("serialized-server-data");
      if (!rawData)
        return [];
      const data = JSON.parse(rawData.innerText)[0].data.sections;
      const tracks = data.find((s) => s.itemKind === "trackLockup")?.items;
      if (!tracks)
        return [];
      return tracks.map((track) => ({
        id: track.contentDescriptor.identifiers.storeAdamID,
        duration: track.duration || "0:00",
        title: track.title,
        url: track.contentDescriptor.url,
        thumbnail: track?.artwork?.dictionary ? makeImage({
          url: track.artwork.dictionary.url,
          height: track.artwork.dictionary.height,
          width: track.artwork.dictionary.width
        }) : "https://music.apple.com/assets/favicon/favicon-180.png",
        artist: {
          name: track.subtitleLinks?.[0]?.title ?? "Unknown Artist"
        }
      }));
    } catch {
      return [];
    }
  }
  static async getSongInfoFallback(res, name, id, link) {
    try {
      const metaTags = res.getElementsByTagName("meta");
      if (!metaTags.length)
        return null;
      const title = metaTags.find((r) => r.getAttribute("name") === "apple:title")?.getAttribute("content") || res.querySelector("title")?.innerText || name;
      const contentId = metaTags.find((r) => r.getAttribute("name") === "apple:content_id")?.getAttribute("content") || id;
      const durationRaw = metaTags.find((r) => r.getAttribute("property") === "music:song:duration")?.getAttribute("content");
      const song = {
        id: contentId,
        duration: durationRaw ? parseDuration(durationRaw) : metaTags.find((m) => m.getAttribute("name") === "apple:description")?.textContent.split("Duration: ")?.[1].split('"')?.[0] || "0:00",
        title,
        url: link,
        thumbnail: metaTags.find((r) => ["og:image:secure_url", "og:image"].includes(r.getAttribute("property")))?.getAttribute("content") || "https://music.apple.com/assets/favicon/favicon-180.png",
        artist: {
          name: res.querySelector(".song-subtitles__artists>a")?.textContent?.trim() || "Apple Music"
        }
      };
      return song;
    } catch {
      return null;
    }
  }
  static async getSongInfo(link) {
    if (!QueryResolver.regex.appleMusicSongRegex.test(link)) {
      return null;
    }
    const url = new URL(link);
    const id = url.searchParams.get("i");
    const name = url.pathname.split("album/")[1]?.split("/")[0];
    if (!id || !name)
      return null;
    const res = await getHTML(`https://music.apple.com/us/song/${name}/${id}`);
    if (!res)
      return null;
    try {
      const datasrc = res.getElementById("serialized-server-data")?.innerText || res.innerText.split('<script type="application/json" id="serialized-server-data">')?.[1]?.split("<\/script>")?.[0];
      if (!datasrc)
        throw "not found";
      const data = JSON.parse(datasrc)[0].data.seoData;
      const song = data.ogSongs[0]?.attributes;
      return {
        id: data.ogSongs[0]?.id || data.appleContentId || id,
        duration: song?.durationInMillis || "0:00",
        title: song?.name || data.appleTitle,
        url: song?.url || data.url || link,
        thumbnail: song?.artwork ? makeImage({
          url: song.artwork.url,
          height: song.artwork.height,
          width: song.artwork.width
        }) : data.artworkUrl ? makeImage({
          height: data.height,
          width: data.width,
          url: data.artworkUrl,
          ext: data.fileType || "jpg"
        }) : "https://music.apple.com/assets/favicon/favicon-180.png",
        artist: {
          name: song?.artistName || data.socialTitle || "Apple Music"
        }
      };
    } catch {
      return this.getSongInfoFallback(res, name, id, link);
    }
  }
  static async getPlaylistInfo(link) {
    if (!QueryResolver.regex.appleMusicPlaylistRegex.test(link)) {
      return null;
    }
    const res = await getHTML(link);
    if (!res)
      return null;
    try {
      const datasrc = res.getElementById("serialized-server-data")?.innerText || res.innerText.split('<script type="application/json" id="serialized-server-data">')?.[1]?.split("<\/script>")?.[0];
      if (!datasrc)
        throw "not found";
      const pl = JSON.parse(datasrc)[0].data.seoData;
      const thumbnail = pl.artworkUrl ? makeImage({
        height: pl.height,
        width: pl.width,
        url: pl.artworkUrl,
        ext: pl.fileType || "jpg"
      }) : "https://music.apple.com/assets/favicon/favicon-180.png";
      return {
        id: pl.appleContentId,
        title: pl.appleTitle,
        thumbnail,
        artist: {
          name: pl.ogSongs?.[0]?.attributes?.artistName || "Apple Music"
        },
        url: pl.url,
        tracks: pl.ogSongs?.map((m) => {
          const song = m.attributes;
          return {
            id: m.id,
            duration: song.durationInMillis || "0:00",
            title: song.name,
            url: song.url,
            thumbnail: song.artwork ? makeImage({
              url: song.artwork.url,
              height: song.artwork.height,
              width: song.artwork.width
            }) : thumbnail,
            artist: {
              name: song.artistName || "Apple Music"
            }
          };
        }) || []
      };
    } catch {
      return null;
    }
  }
  static async getAlbumInfo(link) {
    if (!QueryResolver.regex.appleMusicAlbumRegex.test(link)) {
      return null;
    }
    const res = await getHTML(link);
    if (!res)
      return null;
    try {
      const datasrc = res.getElementById("serialized-server-data")?.innerText || res.innerText.split('<script type="application/json" id="serialized-server-data">')?.[1]?.split("<\/script>")?.[0];
      if (!datasrc)
        throw "not found";
      const pl = JSON.parse(datasrc)[0].data.seoData;
      const thumbnail = pl.artworkUrl ? makeImage({
        height: pl.height,
        width: pl.width,
        url: pl.artworkUrl,
        ext: pl.fileType || "jpg"
      }) : "https://music.apple.com/assets/favicon/favicon-180.png";
      return {
        id: pl.appleContentId,
        title: pl.appleTitle,
        thumbnail,
        artist: {
          name: pl.ogSongs?.[0]?.attributes?.artistName || "Apple Music"
        },
        url: pl.url,
        tracks: pl.ogSongs?.map((m) => {
          const song = m.attributes;
          return {
            id: m.id,
            duration: song.durationInMillis || "0:00",
            title: song.name,
            url: song.url,
            thumbnail: song.artwork ? makeImage({
              url: song.artwork.url,
              height: song.artwork.height,
              width: song.artwork.width
            }) : thumbnail,
            artist: {
              name: song.artistName || "Apple Music"
            }
          };
        }) || []
      };
    } catch {
      return null;
    }
  }
};
__name(AppleMusic, "AppleMusic");

// src/extractors/AppleMusicExtractor.ts
var AppleMusicExtractor = class extends BaseExtractor6 {
  async activate() {
    const lib = await loadYtdl(this.context.player.options.ytdlOptions);
    this._stream = lib.stream;
  }
  async validate(query, type) {
    return [
      QueryType6.APPLE_MUSIC_ALBUM,
      QueryType6.APPLE_MUSIC_PLAYLIST,
      QueryType6.APPLE_MUSIC_SONG,
      QueryType6.APPLE_MUSIC_SEARCH
    ].some((t) => t === type);
  }
  async getRelatedTracks(track) {
    if (track.queryType === QueryType6.APPLE_MUSIC_SONG)
      return this.handle(track.author || track.title, {
        type: QueryType6.APPLE_MUSIC_SEARCH,
        requestedBy: track.requestedBy
      });
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType6.APPLE_MUSIC_SEARCH: {
        const data = await AppleMusic.search(query);
        if (!data || !data.length)
          return this.createResponse();
        const tracks = data.map(
          (m) => new Track6(this.context.player, {
            author: m.artist.name,
            description: m.title,
            duration: typeof m.duration === "number" ? Util6.buildTimeCode(Util6.parseMS(m.duration)) : m.duration,
            thumbnail: m.thumbnail,
            title: m.title,
            url: m.url,
            views: 0,
            source: "apple_music",
            requestedBy: context.requestedBy,
            queryType: "appleMusicSong"
          })
        );
        return this.createResponse(null, tracks);
      }
      case QueryType6.APPLE_MUSIC_ALBUM: {
        const info = await AppleMusic.getAlbumInfo(query);
        if (!info)
          return this.createResponse();
        const playlist = new Playlist3(this.context.player, {
          author: {
            name: info.artist.name,
            url: ""
          },
          description: info.title,
          id: info.id,
          source: "apple_music",
          thumbnail: info.thumbnail,
          title: info.title,
          tracks: [],
          type: "album",
          url: info.url,
          rawPlaylist: info
        });
        playlist.tracks = info.tracks.map(
          (m) => new Track6(this.context.player, {
            author: m.artist.name,
            description: m.title,
            duration: typeof m.duration === "number" ? Util6.buildTimeCode(Util6.parseMS(m.duration)) : m.duration,
            thumbnail: m.thumbnail,
            title: m.title,
            url: m.url,
            views: 0,
            source: "apple_music",
            requestedBy: context.requestedBy,
            queryType: "appleMusicSong"
          })
        );
        return { playlist, tracks: playlist.tracks };
      }
      case QueryType6.APPLE_MUSIC_PLAYLIST: {
        const info = await AppleMusic.getPlaylistInfo(query);
        if (!info)
          return this.createResponse();
        const playlist = new Playlist3(this.context.player, {
          author: {
            name: info.artist.name,
            url: ""
          },
          description: info.title,
          id: info.id,
          source: "apple_music",
          thumbnail: info.thumbnail,
          title: info.title,
          tracks: [],
          type: "playlist",
          url: info.url,
          rawPlaylist: info
        });
        playlist.tracks = info.tracks.map(
          (m) => new Track6(this.context.player, {
            author: m.artist.name,
            description: m.title,
            duration: typeof m.duration === "number" ? Util6.buildTimeCode(Util6.parseMS(m.duration)) : m.duration,
            thumbnail: m.thumbnail,
            title: m.title,
            url: m.url,
            views: 0,
            source: "apple_music",
            requestedBy: context.requestedBy,
            queryType: "appleMusicSong"
          })
        );
        return { playlist, tracks: playlist.tracks };
      }
      case QueryType6.APPLE_MUSIC_SONG: {
        const info = await AppleMusic.getSongInfo(query);
        if (!info)
          return this.createResponse();
        const track = new Track6(this.context.player, {
          author: info.artist.name,
          description: info.title,
          duration: typeof info.duration === "number" ? Util6.buildTimeCode(Util6.parseMS(info.duration)) : info.duration,
          thumbnail: info.thumbnail,
          title: info.title,
          url: info.url,
          views: 0,
          source: "apple_music",
          requestedBy: context.requestedBy,
          queryType: context.type
        });
        return { playlist: null, tracks: [track] };
      }
      default:
        return { playlist: null, tracks: [] };
    }
  }
  async stream(info) {
    if (!this._stream) {
      throw new Error(`Could not find youtube streaming library.`);
    }
    let url = info.url;
    if (YoutubeExtractor.validateURL(info.raw.url))
      url = info.raw.url;
    else {
      const _url = await makeYTSearch(`${info.title} ${info.author}`, "video").then((r) => r[0].url).catch(Util6.noop);
      if (!_url)
        throw new Error(`Could not extract stream for this track`);
      info.raw.url = url = _url;
    }
    return this._stream(url);
  }
};
__name(AppleMusicExtractor, "AppleMusicExtractor");
AppleMusicExtractor.identifier = "com.discord-player.applemusicextractor";

// src/extractors/SpotifyExtractor.ts
import { BaseExtractor as BaseExtractor7, Playlist as Playlist4, QueryType as QueryType7, Track as Track7, Util as Util7 } from "discord-player";
import spotify from "spotify-url-info";
var SpotifyExtractor = class extends BaseExtractor7 {
  async activate() {
    const lib = await loadYtdl(this.context.player.options.ytdlOptions);
    this._stream = lib.stream;
    this._lib = spotify(getFetch);
  }
  async validate(query, type) {
    return [QueryType7.SPOTIFY_ALBUM, QueryType7.SPOTIFY_PLAYLIST, QueryType7.SPOTIFY_SONG].some((t) => t === type);
  }
  async getRelatedTracks(track) {
    return this.createResponse();
  }
  async handle(query, context) {
    switch (context.type) {
      case QueryType7.SPOTIFY_SONG: {
        const spotifyData = await this._lib.getData(query, context.requestOptions).catch(Util7.noop);
        if (!spotifyData)
          return { playlist: null, tracks: [] };
        const spotifyTrack = new Track7(this.context.player, {
          title: spotifyData.title,
          description: `${spotifyData.name} by ${spotifyData.artists.map((m) => m.name).join(", ")}`,
          author: spotifyData.artists[0]?.name ?? "Unknown Artist",
          url: spotifyData.id ? `https://open.spotify.com/track/${spotifyData.id}` : query,
          thumbnail: spotifyData.coverArt?.sources?.[0]?.url || "https://www.scdn.co/i/_global/twitter_card-default.jpg",
          duration: Util7.buildTimeCode(Util7.parseMS(spotifyData.duration ?? spotifyData.maxDuration ?? 0)),
          views: 0,
          requestedBy: context.requestedBy,
          source: "spotify",
          queryType: context.type
        });
        return { playlist: null, tracks: [spotifyTrack] };
      }
      case QueryType7.SPOTIFY_PLAYLIST: {
        const spotifyPlaylist = await this._lib.getData(query, context.requestOptions).catch(Util7.noop);
        if (!spotifyPlaylist)
          return { playlist: null, tracks: [] };
        const playlist = new Playlist4(this.context.player, {
          title: spotifyPlaylist.name ?? spotifyPlaylist.title,
          description: spotifyPlaylist.title ?? "",
          thumbnail: spotifyPlaylist.coverArt?.sources?.[0]?.url ?? "https://www.scdn.co/i/_global/twitter_card-default.jpg",
          type: spotifyPlaylist.type,
          source: "spotify",
          author: {
            name: spotifyPlaylist.subtitle ?? "Unknown Artist",
            url: null
          },
          tracks: [],
          id: spotifyPlaylist.id,
          url: spotifyPlaylist.id ? `https://open.spotify.com/playlist/${spotifyPlaylist.id}` : query,
          rawPlaylist: spotifyPlaylist
        });
        playlist.tracks = spotifyPlaylist.trackList.map((m) => {
          const data = new Track7(this.context.player, {
            title: m.title ?? "",
            description: m.title ?? "",
            author: m.subtitle ?? "Unknown Artist",
            url: m.uid ? `https://open.spotify.com/tracks/${m.uid}` : query,
            thumbnail: "https://www.scdn.co/i/_global/twitter_card-default.jpg",
            duration: Util7.buildTimeCode(Util7.parseMS(m.duration)),
            views: 0,
            requestedBy: context.requestedBy,
            playlist,
            source: "spotify",
            queryType: "spotifySong"
          });
          return data;
        });
        return { playlist, tracks: playlist.tracks };
      }
      case QueryType7.SPOTIFY_ALBUM: {
        const album = await this._lib.getData(query, context.requestOptions).catch(Util7.noop);
        if (!album)
          return { playlist: null, tracks: [] };
        const playlist = new Playlist4(this.context.player, {
          title: album.name ?? album.title,
          description: album.title ?? "",
          thumbnail: album.coverArt?.sources?.[0]?.url ?? "https://www.scdn.co/i/_global/twitter_card-default.jpg",
          type: album.type,
          source: "spotify",
          author: {
            name: album.subtitle ?? "Unknown Artist",
            url: null
          },
          tracks: [],
          id: album.id,
          url: album.id ? `https://open.spotify.com/playlist/${album.id}` : query,
          rawPlaylist: album
        });
        playlist.tracks = album.trackList.map((m) => {
          const data = new Track7(this.context.player, {
            title: m.title ?? "",
            description: m.title ?? "",
            author: m.subtitle ?? "Unknown Artist",
            url: m.uid ? `https://open.spotify.com/tracks/${m.uid}` : query,
            thumbnail: "https://www.scdn.co/i/_global/twitter_card-default.jpg",
            duration: Util7.buildTimeCode(Util7.parseMS(m.duration)),
            views: 0,
            requestedBy: context.requestedBy,
            playlist,
            source: "spotify",
            queryType: "spotifySong"
          });
          return data;
        });
        return { playlist, tracks: playlist.tracks };
      }
      default:
        return { playlist: null, tracks: [] };
    }
  }
  async stream(info) {
    if (!this._stream) {
      throw new Error(`Could not find youtube streaming library.`);
    }
    let url = info.url;
    if (YoutubeExtractor.validateURL(info.raw.url))
      url = info.raw.url;
    else {
      const _url = await makeYTSearch(`${info.title} ${info.author}`, "video").then((r) => r[0].url).catch(Util7.noop);
      if (!_url)
        throw new Error(`Could not extract stream for this track`);
      info.raw.url = url = _url;
    }
    return this._stream(url);
  }
};
__name(SpotifyExtractor, "SpotifyExtractor");
SpotifyExtractor.identifier = "com.discord-player.spotifyextractor";

// src/index.ts
var version = "4.1.1";
export {
  AppleMusicExtractor,
  AttachmentExtractor,
  internal_exports as Internal,
  ReverbnationExtractor,
  SoundCloudExtractor,
  SpotifyExtractor,
  VimeoExtractor,
  YoutubeExtractor as YouTubeExtractor,
  YouTubeLibs,
  YoutubeExtractor,
  createImport,
  getFetch,
  loadYtdl,
  lyricsExtractor,
  makeYTSearch,
  version
};
//# sourceMappingURL=index.mjs.map